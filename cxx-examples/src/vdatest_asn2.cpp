// definitions for module VdaTestModule2 -*- buffer-read-only: t -*-
//
//   This file was generated by esnacc on Fri Dec 26 02:47:30 2025

//   NOTE: this is a machine generated file--editing not recommended


#include "cxx-examples/src/vdatest_asn2.h"

#ifndef NO_NAMESPACE
using namespace SNACC;
namespace VDATestModule2Namespace {
#endif
//------------------------------------------------------------------------------
// value defs

const char *testOID2_2 ="1.2.3.4.5.6.7.8.9.10.4";

const char *testDefinedByDesignation2 ="1.2.3.4.5.6.7.8.9.10.4";


//------------------------------------------------------------------------------
// class member definitions:

// this class will automatically intialize the any hash tbl
class InitAnyVdaTestModule2
{
  public:
    InitAnyVdaTestModule2();
    /* Do not add a destructor to this class!  It could
     * cause pre-mature destruction of the ANY tables.
     * The ANY tables will be destroyed by the runtime library.
     */
};

static InitAnyVdaTestModule2 anyInitalizer;
InitAnyVdaTestModule2::InitAnyVdaTestModule2()
{
    AsnOid oid0("1.2.3.4.5.6.7.8.9.10.4");


    AsnAny::InstallAnyByOid (oid0, testDefinedByDesignation2_ANY_ID, new PrintableString);
}  /* InitAny::InitAny */


void AlgorithmIdentifier::Init(void)
{
  parameters = NULL;
}


int AlgorithmIdentifier::checkConstraints(ConstraintFailList* pConstraintFails) const{
	algorithm.checkConstraints(pConstraintFails);

	if (parameters != NULL)
		parameters->checkConstraints(pConstraintFails);

	return 0;
}


void AlgorithmIdentifier::Clear()
{
  if(parameters)
    delete parameters;
  parameters = NULL;
}

AlgorithmIdentifier::AlgorithmIdentifier(const AlgorithmIdentifier &that)
{
   Init();
   *this = that;
}
AsnType *AlgorithmIdentifier::Clone() const
{
  return new AlgorithmIdentifier(*this);
}

AlgorithmIdentifier &AlgorithmIdentifier::operator = (const AlgorithmIdentifier &that)
{
  if (this != &that)
  {
    Clear();
    algorithm = that.algorithm;
    if (that.parameters)
    {
      if (!parameters)
        parameters = new AsnAny;
      *parameters = *that.parameters;
    }
    else
    {
      delete parameters;
      parameters = NULL;
    }
  }

  return *this;
}

AsnLen
AlgorithmIdentifier::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    if (NOT_NULL(parameters)) {
    l = parameters->BEnc (_b);
    totalLen += l;
  }

    l = algorithm.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, OID_TAG_CODE);
    totalLen += l;

  return totalLen;
} // AlgorithmIdentifier::BEncContent


void AlgorithmIdentifier::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" AlgorithmIdentifier::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OID_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    algorithm.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = _b.PeekByte();

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDecEoc (_b, seqBytesDecoded);

        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (algorithm)", DECODE_ERROR);
  }

  // ANY type
  parameters = new AsnAny;
  parameters->BDec (_b, seqBytesDecoded);


  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // AlgorithmIdentifier::BDecContent

AsnLen AlgorithmIdentifier::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void AlgorithmIdentifier::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" AlgorithmIdentifier::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void AlgorithmIdentifier::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "algorithm ";
	algorithm.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (parameters))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "parameters ";
		parameters->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of AlgorithmIdentifier::Print()

void AlgorithmIdentifier::PrintXML (std::ostream &os, const char *lpszTitle) const
{
    const char *tagName = typeName();
    if (lpszTitle)
        tagName = lpszTitle;
    os << "<" << tagName << ">";
    algorithm.PrintXML(os, "algorithm");

    if (NOT_NULL (parameters)) {
        parameters->PrintXML(os, "parameters");
    }

    os << "</" << tagName << ">";
} // AlgorithmIdentifier::PrintXML


void TestDefinedByUsage_2::Init(void)
{
}


int TestDefinedByUsage_2::checkConstraints(ConstraintFailList* pConstraintFails) const{
	id.checkConstraints(pConstraintFails);

	anyDefBy.checkConstraints(pConstraintFails);

	return 0;
}


void TestDefinedByUsage_2::Clear()
{
}

TestDefinedByUsage_2::TestDefinedByUsage_2(const TestDefinedByUsage_2 &that)
{
   Init();
   *this = that;
}
AsnType *TestDefinedByUsage_2::Clone() const
{
  return new TestDefinedByUsage_2(*this);
}

TestDefinedByUsage_2 &TestDefinedByUsage_2::operator = (const TestDefinedByUsage_2 &that)
{
  if (this != &that)
  {
    Clear();
    id = that.id;
    anyDefBy = that.anyDefBy;
  }

  return *this;
}

AsnLen
TestDefinedByUsage_2::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    anyDefBy.SetTypeByOid (id);
    l = anyDefBy.BEnc (_b);
    totalLen += l;

    l = id.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, OID_TAG_CODE);
    totalLen += l;

  return totalLen;
} // TestDefinedByUsage_2::BEncContent


void TestDefinedByUsage_2::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" TestDefinedByUsage_2::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OID_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    id.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (id)", DECODE_ERROR);
  }

  // ANY type
    anyDefBy.SetTypeByOid (id);
  anyDefBy.BDec (_b, seqBytesDecoded);


  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // TestDefinedByUsage_2::BDecContent

AsnLen TestDefinedByUsage_2::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void TestDefinedByUsage_2::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" TestDefinedByUsage_2::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void TestDefinedByUsage_2::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "id ";
	id.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "anyDefBy ";
	anyDefBy.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of TestDefinedByUsage_2::Print()

void TestDefinedByUsage_2::PrintXML (std::ostream &os, const char *lpszTitle) const
{
    const char *tagName = typeName();
    if (lpszTitle)
        tagName = lpszTitle;
    os << "<" << tagName << ">";
    id.PrintXML(os, "id");

    anyDefBy.PrintXML(os, "anyDefBy");

    os << "</" << tagName << ">";
} // TestDefinedByUsage_2::PrintXML


void TestDefinedByType_2::Init(void)
{
}


int TestDefinedByType_2::checkConstraints(ConstraintFailList* pConstraintFails) const{
	octsName.checkConstraints(pConstraintFails);

	boolTestName.checkConstraints(pConstraintFails);

	return 0;
}


void TestDefinedByType_2::Clear()
{
}

TestDefinedByType_2::TestDefinedByType_2(const TestDefinedByType_2 &that)
{
   Init();
   *this = that;
}
AsnType *TestDefinedByType_2::Clone() const
{
  return new TestDefinedByType_2(*this);
}

TestDefinedByType_2 &TestDefinedByType_2::operator = (const TestDefinedByType_2 &that)
{
  if (this != &that)
  {
    Clear();
    octsName = that.octsName;
    boolTestName = that.boolTestName;
  }

  return *this;
}

AsnLen
TestDefinedByType_2::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = boolTestName.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, UNIV, PRIM, BOOLEAN_TAG_CODE);
    totalLen += l;

    l = octsName.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
    totalLen += l;

  return totalLen;
} // TestDefinedByType_2::BEncContent


void TestDefinedByType_2::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" TestDefinedByType_2::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    octsName.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (octsName)", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, BOOLEAN_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    boolTestName.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (boolTestName)", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // TestDefinedByType_2::BDecContent

AsnLen TestDefinedByType_2::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void TestDefinedByType_2::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" TestDefinedByType_2::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void TestDefinedByType_2::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "octsName ";
	octsName.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "boolTestName ";
	boolTestName.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of TestDefinedByType_2::Print()

void TestDefinedByType_2::PrintXML (std::ostream &os, const char *lpszTitle) const
{
    const char *tagName = typeName();
    if (lpszTitle)
        tagName = lpszTitle;
    os << "<" << tagName << ">";
    octsName.PrintXML(os, "octsName");

    boolTestName.PrintXML(os, "boolTestName");

    os << "</" << tagName << ">";
} // TestDefinedByType_2::PrintXML


void ContentInfo::Init(void)
{
}


int ContentInfo::checkConstraints(ConstraintFailList* pConstraintFails) const{
	contentType.checkConstraints(pConstraintFails);

	content.checkConstraints(pConstraintFails);

	return 0;
}


void ContentInfo::Clear()
{
}

ContentInfo::ContentInfo(const ContentInfo &that)
{
   Init();
   *this = that;
}
AsnType *ContentInfo::Clone() const
{
  return new ContentInfo(*this);
}

ContentInfo &ContentInfo::operator = (const ContentInfo &that)
{
  if (this != &that)
  {
    Clear();
    contentType = that.contentType;
    content = that.content;
  }

  return *this;
}

AsnLen
ContentInfo::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = content.BEnc (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

    l = contentType.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, OID_TAG_CODE);
    totalLen += l;

  return totalLen;
} // ContentInfo::BEncContent


void ContentInfo::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" ContentInfo::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OID_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    contentType.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (contentType)", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  content.BDec (_b, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (content)", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // ContentInfo::BDecContent

AsnLen ContentInfo::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void ContentInfo::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" ContentInfo::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void ContentInfo::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "contentType ";
	contentType.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "content ";
	content.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of ContentInfo::Print()

void ContentInfo::PrintXML (std::ostream &os, const char *lpszTitle) const
{
    const char *tagName = typeName();
    if (lpszTitle)
        tagName = lpszTitle;
    os << "<" << tagName << ">";
    contentType.PrintXML(os, "contentType");

    content.PrintXML(os, "content");

    os << "</" << tagName << ">";
} // ContentInfo::PrintXML


#ifndef NO_NAMESPACE
} // namespace close
#endif
