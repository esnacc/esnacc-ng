// definitions for module VdaTestModule -*- buffer-read-only: t -*-
//
//   This file was generated by esnacc on Fri Dec 26 02:47:27 2025

//   NOTE: this is a machine generated file--editing not recommended


#include "cxx-examples/src/vdatest_asn.h"

#ifndef NO_NAMESPACE
namespace SNACC {
#endif
//------------------------------------------------------------------------------
// value defs

const char *testOID ="1.2.3.4.5.6.7.8.9.10";

const char *testOID2 ="1.2.3.4.5.6.7.8.9.10.2";

const AsnInt maxSIBperMsg (16);

const char *testDefinedByDesignation ="1.2.3.4.5.6.7.8.9.10.2";

const AsnInt appTag20 (20);

const AsnInt appTag21 (21);


//------------------------------------------------------------------------------
// class member definitions:

// this class will automatically intialize the any hash tbl
class InitAnyVdaTestModule
{
  public:
    InitAnyVdaTestModule();
    /* Do not add a destructor to this class!  It could
     * cause pre-mature destruction of the ANY tables.
     * The ANY tables will be destroyed by the runtime library.
     */
};

static InitAnyVdaTestModule anyInitalizer;
InitAnyVdaTestModule::InitAnyVdaTestModule()
{
    AsnOid oid0("1.2.3.4.5.6.7.8.9.10.2");


    AsnAny::InstallAnyByOid (oid0, testDefinedByDesignation_ANY_ID, new PrintableString);
}  /* InitAny::InitAny */


void VDATestSet::Init(void)
{
}

VDATestSet::VDATestSet(const VDATestSet &that)
{
   Init();
   *this = that;
}
void VDATestSet::Clear()
{
}


int VDATestSet::checkConstraints(ConstraintFailList* pConstraintFails) const
{
		setItem1.checkConstraints(pConstraintFails);

		setItem2.checkConstraints(pConstraintFails);

	return 0;
}


AsnType *VDATestSet::Clone() const
{
  return new VDATestSet(*this);
}

VDATestSet &VDATestSet::operator = (const VDATestSet &that)
{
  if (this != &that)
  {
    Clear();
    setItem1 = that.setItem1;
    setItem2 = that.setItem2;
  }

  return *this;
}

AsnLen VDATestSet::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    std::list<AsnBuf> bufList;
    std::list<AsnBuf>::iterator iBuf;
    iBuf = bufList.insert(bufList.begin(), AsnBuf());
    l = setItem2.BEncContent (*iBuf);
    l += BEncDefLen ((*iBuf), l);

    l += BEncTag1 ((*iBuf), UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    iBuf = bufList.insert(bufList.begin(), AsnBuf());
    l = setItem1.BEncContent (*iBuf);
    l += BEncDefLen ((*iBuf), l);

    l += BEncTag1 ((*iBuf), UNIV, PRIM, OCTETSTRING_TAG_CODE);
    totalLen += l;

    sortSet(bufList);
    iBuf = bufList.begin();
    while(iBuf != bufList.end())
    {
       iBuf->ResetMode();
       _b.splice(*iBuf);
       iBuf++;
    }
  return totalLen;
} // VDATestSet::BEncContent


void VDATestSet::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
   FUNC("VDATestSet::BDecContent");
   Clear();
    AsnBufLoc readLoc;
   readLoc = _b.GetReadLoc();
  AsnTag tag1 = AsnTag();
  AsnLen setBytesDecoded = 0;
  unsigned int mandatoryElmtsDecoded = 0;
  AsnLen elmtLen1;

  for (; (setBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN); )
  {
    readLoc = _b.GetReadLoc();
    tag1 = BDecTag (_b, setBytesDecoded);

    if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
    {
      BDEC_2ND_EOC_OCTET (_b, setBytesDecoded);
      break; /* exit for loop */
    }
    elmtLen1 = BDecLen (_b, setBytesDecoded);
    switch (tag1)
    {
      case MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE):
      case MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE):
        setItem1.BDecContent (_b, tag1, elmtLen1, setBytesDecoded);
          mandatoryElmtsDecoded++;
          break;

      case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
        setItem2.BDecContent (_b, tag1, elmtLen1, setBytesDecoded);
          mandatoryElmtsDecoded++;
          break;

       default:
         throw InvalidTagException(typeName(), tag1, STACK_ENTRY);
    } // end switch
  } // end for loop
  bytesDecoded += setBytesDecoded;
  if (mandatoryElmtsDecoded < 2)
  {
     throw EXCEPT("non-optional SET element missing", DECODE_ERROR);
  }
} // VDATestSet::BDecContent

AsnLen
VDATestSet::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SET_TAG_CODE);
  return l;
}

void VDATestSet::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
   FUNC("VDATestSet::BDec");
   AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE))
  {
        throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void VDATestSet::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SET --" << std::endl;
++indent;

	Indent(os, indent);
	os << "setItem1 ";
	setItem1.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "setItem2 ";
	setItem2.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of VDATestSet::Print()

void VDATestSet::PrintXML (std::ostream &os, const char *lpszTitle) const
{
    const char *tagName = typeName();
    if (lpszTitle)
        tagName = lpszTitle;
    os << "<" << tagName << ">";
    setItem1.PrintXML(os, "setItem1");
    setItem2.PrintXML(os, "setItem2");
    os << "</" << tagName << ">";
} // VDATestSet::PrintXML


const SizeConstraint*  
DirectoryString::PrintableString_::SizeConstraints(int &sizeList)const
{
	sizeList = 0;
	return NULL;
}


DirectoryString::DirectoryString(const DirectoryString &that)
{
   Init();
   *this = that;
}
void DirectoryString::Init(void)
{
   // initialize choice to no choiceId to first choice and set pointer to NULL
  choiceId = teletexStringCid;
  teletexString = NULL;
}


int DirectoryString::checkConstraints(ConstraintFailList* pConstraintFails) const
{
	if (teletexString != NULL)
		teletexString->checkConstraints(pConstraintFails);

	if (printableString != NULL)
		printableString->checkConstraints(pConstraintFails);

	if (universalString != NULL)
		universalString->checkConstraints(pConstraintFails);

	if (utf8String != NULL)
		utf8String->checkConstraints(pConstraintFails);

	if (bmpString != NULL)
		bmpString->checkConstraints(pConstraintFails);

	return 0;
}


void DirectoryString::Clear()
{
  switch (choiceId)
  {
    case teletexStringCid:
      delete teletexString;
      teletexString = NULL;
      break;
    case printableStringCid:
      delete printableString;
      printableString = NULL;
      break;
    case universalStringCid:
      delete universalString;
      universalString = NULL;
      break;
    case utf8StringCid:
      delete utf8String;
      utf8String = NULL;
      break;
    case bmpStringCid:
      delete bmpString;
      bmpString = NULL;
      break;
  } // end of switch
} // end of Clear()

AsnType *DirectoryString::Clone() const
{
  return new DirectoryString(*this);
}

DirectoryString &DirectoryString::operator = (const DirectoryString &that)
{
    if (this != &that) {
        Clear();
        if (that.teletexString != NULL) {
            switch (choiceId = that.choiceId) {
                case teletexStringCid:
                    teletexString = new T61String(*that.teletexString);
                break;
                case printableStringCid:
                    printableString = new PrintableString_(*that.printableString);
                break;
                case universalStringCid:
                    universalString = new UniversalString(*that.universalString);
                break;
                case utf8StringCid:
                    utf8String = new UTF8String(*that.utf8String);
                break;
                case bmpStringCid:
                    bmpString = new BMPString(*that.bmpString);
                break;
            }
        }
    }

    return *this;
}

AsnLen
DirectoryString::BEncContent (AsnBuf &_b) const
{
    FUNC("DirectoryString::BEncContent (AsnBuf &_b)");
  AsnLen l=0;
  switch (choiceId)
  {
    case teletexStringCid:
      l = teletexString->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, TELETEXSTRING_TAG_CODE);
      break;

    case printableStringCid:
      l = printableString->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, PRINTABLESTRING_TAG_CODE);
      break;

    case universalStringCid:
      l = universalString->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, UNIVERSALSTRING_TAG_CODE);
      break;

    case utf8StringCid:
      l = utf8String->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, UTF8STRING_TAG_CODE);
      break;

    case bmpStringCid:
      l = bmpString->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, BMPSTRING_TAG_CODE);
      break;

      default:
         throw EXCEPT("Choice is empty", ENCODE_ERROR);
  } // end switch
  return l;
} // DirectoryString::BEncContent


void DirectoryString::BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded /*, s env*/)
{
   FUNC("DirectoryString::BDecContent()");
   Clear();
  switch (tag)
  {
    case MAKE_TAG_ID (UNIV, PRIM, TELETEXSTRING_TAG_CODE):
    case MAKE_TAG_ID (UNIV, CONS, TELETEXSTRING_TAG_CODE):
      choiceId = teletexStringCid;
        teletexString = new T61String;
        teletexString->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (UNIV, PRIM, PRINTABLESTRING_TAG_CODE):
    case MAKE_TAG_ID (UNIV, CONS, PRINTABLESTRING_TAG_CODE):
      choiceId = printableStringCid;
        printableString = new PrintableString_;
        printableString->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (UNIV, PRIM, UNIVERSALSTRING_TAG_CODE):
    case MAKE_TAG_ID (UNIV, CONS, UNIVERSALSTRING_TAG_CODE):
      choiceId = universalStringCid;
        universalString = new UniversalString;
        universalString->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (UNIV, PRIM, UTF8STRING_TAG_CODE):
    case MAKE_TAG_ID (UNIV, CONS, UTF8STRING_TAG_CODE):
      choiceId = utf8StringCid;
        utf8String = new UTF8String;
        utf8String->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    case MAKE_TAG_ID (UNIV, PRIM, BMPSTRING_TAG_CODE):
    case MAKE_TAG_ID (UNIV, CONS, BMPSTRING_TAG_CODE):
      choiceId = bmpStringCid;
        bmpString = new BMPString;
        bmpString->BDecContent (_b, tag, elmtLen0, bytesDecoded);
      break;

    default:
    {        throw InvalidTagException(typeName(), tag, STACK_ENTRY);
      break;
    }
  } // end switch
} // DirectoryString::BDecContent


AsnLen DirectoryString::BEnc (AsnBuf &_b) const
{
    AsnLen l=0;
    l = BEncContent (_b);
    return l;
}

void DirectoryString::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
    AsnLen elmtLen = 0;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (_b, bytesDecoded);
    elmtLen = BDecLen (_b, bytesDecoded);
    BDecContent (_b, tag, elmtLen, bytesDecoded);
}

void DirectoryString::Print(std::ostream& os, unsigned short indent) const
{
	switch (choiceId)
	{
	case teletexStringCid:
		os << "teletexString ";
		if (teletexString)
			teletexString->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case printableStringCid:
		os << "printableString ";
		if (printableString)
			printableString->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case universalStringCid:
		os << "universalString ";
		if (universalString)
			universalString->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case utf8StringCid:
		os << "utf8String ";
		if (utf8String)
			utf8String->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case bmpStringCid:
		os << "bmpString ";
		if (bmpString)
			bmpString->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	} // end of switch
} // end of DirectoryString::Print()

void DirectoryString::PrintXML (std::ostream &os, const char *lpszTitle) const
{
    const char *tagName = typeName();
    if (lpszTitle)
        tagName = lpszTitle;    os << "<" << tagName << ">";
    switch (choiceId) {
    case teletexStringCid:
       if (teletexString) {
           teletexString->PrintXML(os,"teletexString");
      }
      break;

    case printableStringCid:
       if (printableString) {
           printableString->PrintXML(os,"printableString");
      }
      break;

    case universalStringCid:
       if (universalString) {
           universalString->PrintXML(os,"universalString");
      }
      break;

    case utf8StringCid:
       if (utf8String) {
           utf8String->PrintXML(os,"utf8String");
      }
      break;

    case bmpStringCid:
       if (bmpString) {
           bmpString->PrintXML(os,"bmpString");
      }
      break;

    } // end of switch
    os << "</" << tagName << ">";
} // DirectoryString::PrintXML

void CompleteSIBshort::Init(void)
{
}


int CompleteSIBshort::checkConstraints(ConstraintFailList* pConstraintFails) const{
	a.checkConstraints(pConstraintFails);

	return 0;
}


void CompleteSIBshort::Clear()
{
}

CompleteSIBshort::CompleteSIBshort(const CompleteSIBshort &that)
{
   Init();
   *this = that;
}
AsnType *CompleteSIBshort::Clone() const
{
  return new CompleteSIBshort(*this);
}

CompleteSIBshort &CompleteSIBshort::operator = (const CompleteSIBshort &that)
{
  if (this != &that)
  {
    Clear();
    a = that.a;
  }

  return *this;
}

AsnLen
CompleteSIBshort::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = a.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

  return totalLen;
} // CompleteSIBshort::BEncContent


void CompleteSIBshort::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" CompleteSIBshort::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    a.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (a)", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // CompleteSIBshort::BDecContent

AsnLen CompleteSIBshort::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void CompleteSIBshort::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" CompleteSIBshort::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void CompleteSIBshort::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "a ";
	a.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of CompleteSIBshort::Print()

void CompleteSIBshort::PrintXML (std::ostream &os, const char *lpszTitle) const
{
    const char *tagName = typeName();
    if (lpszTitle)
        tagName = lpszTitle;
    os << "<" << tagName << ">";
    a.PrintXML(os, "a");

    os << "</" << tagName << ">";
} // CompleteSIBshort::PrintXML


void SequenceOfDefaults::Init(void)
{
  defBool = new AsnBool(false);
  defBitstring = new ClassList(25);
  defBitstring->SetBit(ClassList::unclassified);
  defInteger = new Version(2);
  defEnumerated = new Enumeration(1);
}


int SequenceOfDefaults::checkConstraints(ConstraintFailList* pConstraintFails) const{
	if (defBool != NULL)
		defBool->checkConstraints(pConstraintFails);

	if (defBitstring != NULL)
		defBitstring->checkConstraints(pConstraintFails);

	if (defInteger != NULL)
		defInteger->checkConstraints(pConstraintFails);

	if (defEnumerated != NULL)
		defEnumerated->checkConstraints(pConstraintFails);

	return 0;
}


void SequenceOfDefaults::Clear()
{
  if(defBool)
    delete defBool;
  defBool = NULL;
  if(defBitstring)
    delete defBitstring;
  defBitstring = NULL;
  if(defInteger)
    delete defInteger;
  defInteger = NULL;
  if(defEnumerated)
    delete defEnumerated;
  defEnumerated = NULL;
}

SequenceOfDefaults::SequenceOfDefaults(const SequenceOfDefaults &that)
{
   Init();
   *this = that;
}
AsnType *SequenceOfDefaults::Clone() const
{
  return new SequenceOfDefaults(*this);
}

SequenceOfDefaults &SequenceOfDefaults::operator = (const SequenceOfDefaults &that)
{
  if (this != &that)
  {
    Clear();
    if (that.defBool)
    {
      if (!defBool)
        defBool = new AsnBool;
      *defBool = *that.defBool;
    }
    else
    {
      delete defBool;
      defBool = NULL;
    }
    if (that.defBitstring)
    {
      if (!defBitstring)
        defBitstring = new ClassList;
      *defBitstring = *that.defBitstring;
    }
    else
    {
      delete defBitstring;
      defBitstring = NULL;
    }
    if (that.defInteger)
    {
      if (!defInteger)
        defInteger = new Version;
      *defInteger = *that.defInteger;
    }
    else
    {
      delete defInteger;
      defInteger = NULL;
    }
    if (that.defEnumerated)
    {
      if (!defEnumerated)
        defEnumerated = new Enumeration;
      *defEnumerated = *that.defEnumerated;
    }
    else
    {
      delete defEnumerated;
      defEnumerated = NULL;
    }
  }

  return *this;
}

AsnLen
SequenceOfDefaults::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if ( NOT_NULL(defEnumerated) && *defEnumerated != 1 )
  {
    l = defEnumerated->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, UNIV, PRIM, ENUM_TAG_CODE);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 3);
    totalLen += l;
  }

  if ( NOT_NULL(defInteger) && *defInteger != 2 )
  {
    l = defInteger->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, INTEGER_TAG_CODE);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;
  }

    if (NOT_NULL(defBitstring) && (!defBitstring->soloBitCheck(ClassList::unclassified))) {
    l = defBitstring->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, BITSTRING_TAG_CODE);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 1);
    totalLen += l;
  }

    if (NOT_NULL(defBool) && *defBool != false ) {
    l = defBool->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, UNIV, PRIM, BOOLEAN_TAG_CODE);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;
  }

  return totalLen;
} // SequenceOfDefaults::BEncContent


void SequenceOfDefaults::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" SequenceOfDefaults::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  if (elmtLen0 == 0)
    return;
  else
  {
    tag1 = BDecTag (_b, seqBytesDecoded);

    if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
    {
      BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
      bytesDecoded += seqBytesDecoded;
      return;
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);

    if (tag1 != MAKE_TAG_ID (UNIV, PRIM, BOOLEAN_TAG_CODE))
    {
          throw InvalidTagException(typeName(), tag1, STACK_ENTRY);
    }

    elmtLen2 = BDecLen (_b, seqBytesDecoded);
  // delete default value
  delete defBool;
  defBool = new AsnBool;
    defBool->BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 1)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);

    if ((tag1 != MAKE_TAG_ID (UNIV, PRIM, BITSTRING_TAG_CODE))
       && (tag1 != MAKE_TAG_ID (UNIV, CONS, BITSTRING_TAG_CODE)))
    {
          throw InvalidTagException(typeName(), tag1, STACK_ENTRY);
    }

    elmtLen2 = BDecLen (_b, seqBytesDecoded);
  // delete default value
  delete defBitstring;
  defBitstring = new ClassList;
    defBitstring->BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);

    if (tag1 != MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))
    {
          throw InvalidTagException(typeName(), tag1, STACK_ENTRY);
    }

    elmtLen2 = BDecLen (_b, seqBytesDecoded);
  // delete default value
  delete defInteger;
  defInteger = new Version;
    defInteger->BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 3)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);

    if (tag1 != MAKE_TAG_ID (UNIV, PRIM, ENUM_TAG_CODE))
    {
          throw InvalidTagException(typeName(), tag1, STACK_ENTRY);
    }

    elmtLen2 = BDecLen (_b, seqBytesDecoded);
  // delete default value
  delete defEnumerated;
  defEnumerated = new Enumeration;
    defEnumerated->BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // SequenceOfDefaults::BDecContent

AsnLen SequenceOfDefaults::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void SequenceOfDefaults::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" SequenceOfDefaults::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void SequenceOfDefaults::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
	int nonePrinted = true;
++indent;

	if (NOT_NULL (defBool))
	{
		nonePrinted = false;
		Indent(os, indent);
		os << "defBool ";
		defBool->Print(os, indent);
	}

	if (NOT_NULL (defBitstring))
	{
		if (!nonePrinted)
			os << "," << std::endl;
		nonePrinted = false;
		Indent(os, indent);
		os << "defBitstring ";
		defBitstring->Print(os, indent);
	}

	if (NOT_NULL (defInteger))
	{
		if (!nonePrinted)
			os << "," << std::endl;
		nonePrinted = false;
		Indent(os, indent);
		os << "defInteger ";
		defInteger->Print(os, indent);
	}

	if (NOT_NULL (defEnumerated))
	{
		if (!nonePrinted)
			os << "," << std::endl;
		nonePrinted = false;
		Indent(os, indent);
		os << "defEnumerated ";
		defEnumerated->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of SequenceOfDefaults::Print()

void SequenceOfDefaults::PrintXML (std::ostream &os, const char *lpszTitle) const
{
    const char *tagName = typeName();
    if (lpszTitle)
        tagName = lpszTitle;
    os << "<" << tagName << ">";
    if (NOT_NULL (defBool)) {
        defBool->PrintXML(os, "defBool");
    }

    if (NOT_NULL (defBitstring)) {
        defBitstring->PrintXML(os, "defBitstring");
    }

    if (NOT_NULL (defInteger)) {
        defInteger->PrintXML(os, "defInteger");
    }

    if (NOT_NULL (defEnumerated)) {
        defEnumerated->PrintXML(os, "defEnumerated");
    }

    os << "</" << tagName << ">";
} // SequenceOfDefaults::PrintXML


void TestAllAsnPrimativeTypes::Init(void)
{
  oidName = NULL;
  realName = NULL;
}


int TestAllAsnPrimativeTypes::checkConstraints(ConstraintFailList* pConstraintFails) const{
	octsName.checkConstraints(pConstraintFails);

	boolTestName.checkConstraints(pConstraintFails);

	if (oidName != NULL)
		oidName->checkConstraints(pConstraintFails);

	bitStringName.checkConstraints(pConstraintFails);

	integerName.checkConstraints(pConstraintFails);

	enumTestName.checkConstraints(pConstraintFails);

	if (realName != NULL)
		realName->checkConstraints(pConstraintFails);

	nullName.checkConstraints(pConstraintFails);

	return 0;
}


void TestAllAsnPrimativeTypes::Clear()
{
  if(oidName)
    delete oidName;
  oidName = NULL;
  if(realName)
    delete realName;
  realName = NULL;
}

TestAllAsnPrimativeTypes::TestAllAsnPrimativeTypes(const TestAllAsnPrimativeTypes &that)
{
   Init();
   *this = that;
}
AsnType *TestAllAsnPrimativeTypes::Clone() const
{
  return new TestAllAsnPrimativeTypes(*this);
}

TestAllAsnPrimativeTypes &TestAllAsnPrimativeTypes::operator = (const TestAllAsnPrimativeTypes &that)
{
  if (this != &that)
  {
    Clear();
    octsName = that.octsName;
    boolTestName = that.boolTestName;
    if (that.oidName)
    {
      if (!oidName)
        oidName = new AsnOid;
      *oidName = *that.oidName;
    }
    else
    {
      delete oidName;
      oidName = NULL;
    }
    bitStringName = that.bitStringName;
    integerName = that.integerName;
    enumTestName = that.enumTestName;
    if (that.realName)
    {
      if (!realName)
        realName = new AsnReal;
      *realName = *that.realName;
    }
    else
    {
      delete realName;
      realName = NULL;
    }
    nullName = that.nullName;
  }

  return *this;
}

AsnLen
TestAllAsnPrimativeTypes::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = nullName.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, UNIV, PRIM, NULLTYPE_TAG_CODE);
    totalLen += l;

    if (NOT_NULL(realName)) {
    l = realName->BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, UNIV, PRIM, REAL_TAG_CODE);
    totalLen += l;
  }

    l = enumTestName.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, UNIV, PRIM, ENUM_TAG_CODE);
    totalLen += l;

    l = integerName.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = bitStringName.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, CNTX, PRIM, 2);
    totalLen += l;

    if (NOT_NULL(oidName)) {
    l = oidName->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, OID_TAG_CODE);
    totalLen += l;
  }

    l = boolTestName.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, UNIV, PRIM, BOOLEAN_TAG_CODE);
    totalLen += l;

    l = octsName.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
    totalLen += l;

  return totalLen;
} // TestAllAsnPrimativeTypes::BEncContent


void TestAllAsnPrimativeTypes::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" TestAllAsnPrimativeTypes::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    octsName.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (octsName)", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, BOOLEAN_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    boolTestName.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (boolTestName)", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OID_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  oidName = new AsnOid;
    oidName->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, PRIM, 2))
    || (tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    bitStringName.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (bitStringName)", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    integerName.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (integerName)", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, ENUM_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    enumTestName.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (enumTestName)", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, REAL_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  realName = new AsnReal;
    realName->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, NULLTYPE_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    nullName.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (nullName)", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // TestAllAsnPrimativeTypes::BDecContent

AsnLen TestAllAsnPrimativeTypes::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void TestAllAsnPrimativeTypes::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" TestAllAsnPrimativeTypes::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void TestAllAsnPrimativeTypes::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "octsName ";
	octsName.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "boolTestName ";
	boolTestName.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (oidName))
	{
		Indent(os, indent);
		os << "oidName ";
		oidName->Print(os, indent);
	}

	Indent(os, indent);
	os << "bitStringName ";
	bitStringName.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "integerName ";
	integerName.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "enumTestName ";
	enumTestName.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (realName))
	{
		Indent(os, indent);
		os << "realName ";
		realName->Print(os, indent);
	}

	Indent(os, indent);
	os << "nullName ";
	nullName.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of TestAllAsnPrimativeTypes::Print()

void TestAllAsnPrimativeTypes::PrintXML (std::ostream &os, const char *lpszTitle) const
{
    const char *tagName = typeName();
    if (lpszTitle)
        tagName = lpszTitle;
    os << "<" << tagName << ">";
    octsName.PrintXML(os, "octsName");

    boolTestName.PrintXML(os, "boolTestName");

    if (NOT_NULL (oidName)) {
        oidName->PrintXML(os, "oidName");
    }

    bitStringName.PrintXML(os, "bitStringName");

    integerName.PrintXML(os, "integerName");

    enumTestName.PrintXML(os, "enumTestName");

    if (NOT_NULL (realName)) {
        realName->PrintXML(os, "realName");
    }

    nullName.PrintXML(os, "nullName");

    os << "</" << tagName << ">";
} // TestAllAsnPrimativeTypes::PrintXML


void TestSetSorting1::Init(void)
{
}

TestSetSorting1::TestSetSorting1(const TestSetSorting1 &that)
{
   Init();
   *this = that;
}
void TestSetSorting1::Clear()
{
}


int TestSetSorting1::checkConstraints(ConstraintFailList* pConstraintFails) const
{
		null.checkConstraints(pConstraintFails);

		num.checkConstraints(pConstraintFails);

		oid.checkConstraints(pConstraintFails);

		octs.checkConstraints(pConstraintFails);

		bits.checkConstraints(pConstraintFails);

		ps.checkConstraints(pConstraintFails);

		seq.checkConstraints(pConstraintFails);

		set.checkConstraints(pConstraintFails);

	return 0;
}


AsnType *TestSetSorting1::Clone() const
{
  return new TestSetSorting1(*this);
}

TestSetSorting1 &TestSetSorting1::operator = (const TestSetSorting1 &that)
{
  if (this != &that)
  {
    Clear();
    null = that.null;
    num = that.num;
    oid = that.oid;
    octs = that.octs;
    bits = that.bits;
    ps = that.ps;
    seq = that.seq;
    set = that.set;
  }

  return *this;
}

AsnLen TestSetSorting1::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    std::list<AsnBuf> bufList;
    std::list<AsnBuf>::iterator iBuf;
    iBuf = bufList.insert(bufList.begin(), AsnBuf());
    l = set.BEncContent (*iBuf);
    l += BEncConsLen ((*iBuf), l);

    l += BEncTag1 ((*iBuf), UNIV, CONS, SET_TAG_CODE);
    totalLen += l;

    iBuf = bufList.insert(bufList.begin(), AsnBuf());
    l = seq.BEncContent (*iBuf);
    l += BEncConsLen ((*iBuf), l);

    l += BEncTag1 ((*iBuf), UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

    iBuf = bufList.insert(bufList.begin(), AsnBuf());
    l = ps.BEncContent (*iBuf);
    l += BEncDefLen ((*iBuf), l);

    l += BEncTag1 ((*iBuf), UNIV, PRIM, PRINTABLESTRING_TAG_CODE);
    totalLen += l;

    iBuf = bufList.insert(bufList.begin(), AsnBuf());
    l = bits.BEncContent (*iBuf);
    l += BEncDefLen ((*iBuf), l);

    l += BEncTag1 ((*iBuf), UNIV, PRIM, BITSTRING_TAG_CODE);
    totalLen += l;

    iBuf = bufList.insert(bufList.begin(), AsnBuf());
    l = octs.BEncContent (*iBuf);
    l += BEncDefLen ((*iBuf), l);

    l += BEncTag1 ((*iBuf), UNIV, PRIM, OCTETSTRING_TAG_CODE);
    totalLen += l;

    iBuf = bufList.insert(bufList.begin(), AsnBuf());
    l = oid.BEncContent (*iBuf);
    l += BEncDefLen ((*iBuf), l);

    l += BEncTag1 ((*iBuf), UNIV, PRIM, OID_TAG_CODE);
    totalLen += l;

    iBuf = bufList.insert(bufList.begin(), AsnBuf());
    l = num.BEncContent (*iBuf);
    l += BEncDefLen ((*iBuf), l);

    l += BEncTag1 ((*iBuf), UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    iBuf = bufList.insert(bufList.begin(), AsnBuf());
    l = null.BEncContent (*iBuf);
    BEncDefLenTo127 ((*iBuf), l);
    l++;

    l += BEncTag1 ((*iBuf), UNIV, PRIM, NULLTYPE_TAG_CODE);
    totalLen += l;

    sortSet(bufList);
    iBuf = bufList.begin();
    while(iBuf != bufList.end())
    {
       iBuf->ResetMode();
       _b.splice(*iBuf);
       iBuf++;
    }
  return totalLen;
} // TestSetSorting1::BEncContent


void TestSetSorting1::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
   FUNC("TestSetSorting1::BDecContent");
   Clear();
    AsnBufLoc readLoc;
   readLoc = _b.GetReadLoc();
  AsnTag tag1 = AsnTag();
  AsnLen setBytesDecoded = 0;
  unsigned int mandatoryElmtsDecoded = 0;
  AsnLen elmtLen1;

  for (; (setBytesDecoded < elmtLen0) || (elmtLen0 == INDEFINITE_LEN); )
  {
    readLoc = _b.GetReadLoc();
    tag1 = BDecTag (_b, setBytesDecoded);

    if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
    {
      BDEC_2ND_EOC_OCTET (_b, setBytesDecoded);
      break; /* exit for loop */
    }
    elmtLen1 = BDecLen (_b, setBytesDecoded);
    switch (tag1)
    {
      case MAKE_TAG_ID (UNIV, PRIM, NULLTYPE_TAG_CODE):
        null.BDecContent (_b, tag1, elmtLen1, setBytesDecoded);
          mandatoryElmtsDecoded++;
          break;

      case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
        num.BDecContent (_b, tag1, elmtLen1, setBytesDecoded);
          mandatoryElmtsDecoded++;
          break;

      case MAKE_TAG_ID (UNIV, PRIM, OID_TAG_CODE):
        oid.BDecContent (_b, tag1, elmtLen1, setBytesDecoded);
          mandatoryElmtsDecoded++;
          break;

      case MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE):
      case MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE):
        octs.BDecContent (_b, tag1, elmtLen1, setBytesDecoded);
          mandatoryElmtsDecoded++;
          break;

      case MAKE_TAG_ID (UNIV, PRIM, BITSTRING_TAG_CODE):
      case MAKE_TAG_ID (UNIV, CONS, BITSTRING_TAG_CODE):
        bits.BDecContent (_b, tag1, elmtLen1, setBytesDecoded);
          mandatoryElmtsDecoded++;
          break;

      case MAKE_TAG_ID (UNIV, PRIM, PRINTABLESTRING_TAG_CODE):
      case MAKE_TAG_ID (UNIV, CONS, PRINTABLESTRING_TAG_CODE):
        ps.BDecContent (_b, tag1, elmtLen1, setBytesDecoded);
          mandatoryElmtsDecoded++;
          break;

      case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
        seq.BDecContent (_b, tag1, elmtLen1, setBytesDecoded);
          mandatoryElmtsDecoded++;
          break;

      case MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE):
        set.BDecContent (_b, tag1, elmtLen1, setBytesDecoded);
          mandatoryElmtsDecoded++;
          break;

       default:
         throw InvalidTagException(typeName(), tag1, STACK_ENTRY);
    } // end switch
  } // end for loop
  bytesDecoded += setBytesDecoded;
  if (mandatoryElmtsDecoded < 8)
  {
     throw EXCEPT("non-optional SET element missing", DECODE_ERROR);
  }
} // TestSetSorting1::BDecContent

AsnLen
TestSetSorting1::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SET_TAG_CODE);
  return l;
}

void TestSetSorting1::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
   FUNC("TestSetSorting1::BDec");
   AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE))
  {
        throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void TestSetSorting1::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SET --" << std::endl;
++indent;

	Indent(os, indent);
	os << "null ";
	null.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "num ";
	num.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "oid ";
	oid.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "octs ";
	octs.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "bits ";
	bits.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "ps ";
	ps.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "seq ";
	seq.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "set ";
	set.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of TestSetSorting1::Print()

void TestSetSorting1::PrintXML (std::ostream &os, const char *lpszTitle) const
{
    const char *tagName = typeName();
    if (lpszTitle)
        tagName = lpszTitle;
    os << "<" << tagName << ">";
    null.PrintXML(os, "null");
    num.PrintXML(os, "num");
    oid.PrintXML(os, "oid");
    octs.PrintXML(os, "octs");
    bits.PrintXML(os, "bits");
    ps.PrintXML(os, "ps");
    seq.PrintXML(os, "seq");
    set.PrintXML(os, "set");
    os << "</" << tagName << ">";
} // TestSetSorting1::PrintXML


void TestSequence::Init(void)
{
  seqOfDefaults = NULL;
}


int TestSequence::checkConstraints(ConstraintFailList* pConstraintFails) const{
	if (seqOfDefaults != NULL)
		seqOfDefaults->checkConstraints(pConstraintFails);

	testSet.checkConstraints(pConstraintFails);

	testSetOfAny.checkConstraints(pConstraintFails);

	directoryString.checkConstraints(pConstraintFails);

	testAllPrimatives.checkConstraints(pConstraintFails);

	return 0;
}


void TestSequence::Clear()
{
  if(seqOfDefaults)
    delete seqOfDefaults;
  seqOfDefaults = NULL;
  testSet.Clear();
  directoryString.Clear();
  testAllPrimatives.Clear();
}

TestSequence::TestSequence(const TestSequence &that)
{
   Init();
   *this = that;
}
AsnType *TestSequence::Clone() const
{
  return new TestSequence(*this);
}

TestSequence &TestSequence::operator = (const TestSequence &that)
{
  if (this != &that)
  {
    Clear();
    if (that.seqOfDefaults)
    {
      if (!seqOfDefaults)
        seqOfDefaults = new SequenceOfDefaults;
      *seqOfDefaults = *that.seqOfDefaults;
    }
    else
    {
      delete seqOfDefaults;
      seqOfDefaults = NULL;
    }
    testSet = that.testSet;
    testSetOfAny = that.testSetOfAny;
    directoryString = that.directoryString;
    testAllPrimatives = that.testAllPrimatives;
  }

  return *this;
}

AsnLen
TestSequence::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = testAllPrimatives.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;

    l = directoryString.BEncContent (_b);
    totalLen += l;

    l = testSetOfAny.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, UNIV, CONS, SET_TAG_CODE);
    totalLen += l;

    l = testSet.BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, UNIV, CONS, SET_TAG_CODE);
    totalLen += l;

    if (NOT_NULL(seqOfDefaults)) {
    l = seqOfDefaults->BEncContent (_b);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
    totalLen += l;
  }

  return totalLen;
} // TestSequence::BEncContent


void TestSequence::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" TestSequence::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
  seqOfDefaults = new SequenceOfDefaults;
    seqOfDefaults->BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    testSet.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (testSet)", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SET_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    testSetOfAny.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (testSetOfAny)", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, TELETEXSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, TELETEXSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, PRIM, PRINTABLESTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, PRINTABLESTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, PRIM, UNIVERSALSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, UNIVERSALSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, PRIM, UTF8STRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, UTF8STRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, PRIM, BMPSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, BMPSTRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    directoryString.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (directoryString)", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    testAllPrimatives.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (testAllPrimatives)", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // TestSequence::BDecContent

AsnLen TestSequence::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void TestSequence::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" TestSequence::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void TestSequence::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	if (NOT_NULL (seqOfDefaults))
	{
		Indent(os, indent);
		os << "seqOfDefaults ";
		seqOfDefaults->Print(os, indent);
	}

	Indent(os, indent);
	os << "testSet ";
	testSet.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "testSetOfAny ";
	testSetOfAny.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "directoryString ";
	directoryString.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "testAllPrimatives ";
	testAllPrimatives.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of TestSequence::Print()

void TestSequence::PrintXML (std::ostream &os, const char *lpszTitle) const
{
    const char *tagName = typeName();
    if (lpszTitle)
        tagName = lpszTitle;
    os << "<" << tagName << ">";
    if (NOT_NULL (seqOfDefaults)) {
        seqOfDefaults->PrintXML(os, "seqOfDefaults");
    }

    testSet.PrintXML(os, "testSet");

    testSetOfAny.PrintXML(os, "testSetOfAny");

    directoryString.PrintXML(os, "directoryString");

    testAllPrimatives.PrintXML(os, "testAllPrimatives");

    os << "</" << tagName << ">";
} // TestSequence::PrintXML


void TestDefinedByUsage::Init(void)
{
}


int TestDefinedByUsage::checkConstraints(ConstraintFailList* pConstraintFails) const{
	id.checkConstraints(pConstraintFails);

	anyDefBy.checkConstraints(pConstraintFails);

	i1.checkConstraints(pConstraintFails);

	i2.checkConstraints(pConstraintFails);

	i3.checkConstraints(pConstraintFails);

	i4.checkConstraints(pConstraintFails);

	return 0;
}


void TestDefinedByUsage::Clear()
{
}

TestDefinedByUsage::TestDefinedByUsage(const TestDefinedByUsage &that)
{
   Init();
   *this = that;
}
AsnType *TestDefinedByUsage::Clone() const
{
  return new TestDefinedByUsage(*this);
}

TestDefinedByUsage &TestDefinedByUsage::operator = (const TestDefinedByUsage &that)
{
  if (this != &that)
  {
    Clear();
    id = that.id;
    anyDefBy = that.anyDefBy;
    i1 = that.i1;
    i2 = that.i2;
    i3 = that.i3;
    i4 = that.i4;
  }

  return *this;
}

AsnLen
TestDefinedByUsage::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = i4.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = i3.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = i2.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    l = i1.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, INTEGER_TAG_CODE);
    totalLen += l;

    anyDefBy.SetTypeByOid (id);
    l = anyDefBy.BEnc (_b);
    totalLen += l;

    l = id.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, OID_TAG_CODE);
    totalLen += l;

  return totalLen;
} // TestDefinedByUsage::BEncContent


void TestDefinedByUsage::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" TestDefinedByUsage::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OID_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    id.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (id)", DECODE_ERROR);
  }

  // ANY type
    anyDefBy.SetTypeByOid (id);
  anyDefBy.BDec (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);


  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    i1.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (i1)", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    i2.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (i2)", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    i3.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (i3)", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    i4.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (i4)", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // TestDefinedByUsage::BDecContent

AsnLen TestDefinedByUsage::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void TestDefinedByUsage::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" TestDefinedByUsage::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void TestDefinedByUsage::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "id ";
	id.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "anyDefBy ";
	anyDefBy.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "i1 ";
	i1.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "i2 ";
	i2.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "i3 ";
	i3.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "i4 ";
	i4.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of TestDefinedByUsage::Print()

void TestDefinedByUsage::PrintXML (std::ostream &os, const char *lpszTitle) const
{
    const char *tagName = typeName();
    if (lpszTitle)
        tagName = lpszTitle;
    os << "<" << tagName << ">";
    id.PrintXML(os, "id");

    anyDefBy.PrintXML(os, "anyDefBy");

    i1.PrintXML(os, "i1");

    i2.PrintXML(os, "i2");

    i3.PrintXML(os, "i3");

    i4.PrintXML(os, "i4");

    os << "</" << tagName << ">";
} // TestDefinedByUsage::PrintXML


void TestDefinedByType::Init(void)
{
}


int TestDefinedByType::checkConstraints(ConstraintFailList* pConstraintFails) const{
	octsName.checkConstraints(pConstraintFails);

	boolTestName.checkConstraints(pConstraintFails);

	return 0;
}


void TestDefinedByType::Clear()
{
}

TestDefinedByType::TestDefinedByType(const TestDefinedByType &that)
{
   Init();
   *this = that;
}
AsnType *TestDefinedByType::Clone() const
{
  return new TestDefinedByType(*this);
}

TestDefinedByType &TestDefinedByType::operator = (const TestDefinedByType &that)
{
  if (this != &that)
  {
    Clear();
    octsName = that.octsName;
    boolTestName = that.boolTestName;
  }

  return *this;
}

AsnLen
TestDefinedByType::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

    l = boolTestName.BEncContent (_b);
    BEncDefLenTo127 (_b, l);
    l++;

    l += BEncTag1 (_b, UNIV, PRIM, BOOLEAN_TAG_CODE);
    totalLen += l;

    l = octsName.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, OCTETSTRING_TAG_CODE);
    totalLen += l;

  return totalLen;
} // TestDefinedByType::BEncContent


void TestDefinedByType::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" TestDefinedByType::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE))
    || (tag1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    octsName.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (octsName)", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, PRIM, BOOLEAN_TAG_CODE)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    boolTestName.BDecContent (_b, tag1, elmtLen1, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (boolTestName)", DECODE_ERROR);
  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // TestDefinedByType::BDecContent

AsnLen TestDefinedByType::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void TestDefinedByType::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" TestDefinedByType::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void TestDefinedByType::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "octsName ";
	octsName.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "boolTestName ";
	boolTestName.Print(os, indent);

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of TestDefinedByType::Print()

void TestDefinedByType::PrintXML (std::ostream &os, const char *lpszTitle) const
{
    const char *tagName = typeName();
    if (lpszTitle)
        tagName = lpszTitle;
    os << "<" << tagName << ">";
    octsName.PrintXML(os, "octsName");

    boolTestName.PrintXML(os, "boolTestName");

    os << "</" << tagName << ">";
} // TestDefinedByType::PrintXML


Application_TagTest::I1Tag & 
Application_TagTest::I1Tag::operator =(const I1Tag &that)
{
	m_len = that.m_len;
	delete[] m_bytes;
	m_bytes = new unsigned char[m_len];
	memcpy(m_bytes, that.m_bytes, m_len);
	return *this;
}

const ValueRange*  
Application_TagTest::I1Tag::ValueRanges(int &sizeVRList) const
{
		static const ValueRange i1Tag_ValueRangeList[] = 
			{{ 0, 23, 1 }};

		sizeVRList = 1;
		return &i1Tag_ValueRangeList[0];
}

Application_TagTest::I2Tag & 
Application_TagTest::I2Tag::operator =(const I2Tag &that)
{
	m_len = that.m_len;
	delete[] m_bytes;
	m_bytes = new unsigned char[m_len];
	memcpy(m_bytes, that.m_bytes, m_len);
	return *this;
}

const ValueRange*  
Application_TagTest::I2Tag::ValueRanges(int &sizeVRList) const
{
		static const ValueRange i2Tag_ValueRangeList[] = 
			{{ 0, 59, 1 }};

		sizeVRList = 1;
		return &i2Tag_ValueRangeList[0];
}

Application_TagTest::I4Tag & 
Application_TagTest::I4Tag::operator =(const I4Tag &that)
{
	m_len = that.m_len;
	delete[] m_bytes;
	m_bytes = new unsigned char[m_len];
	memcpy(m_bytes, that.m_bytes, m_len);
	return *this;
}

const ValueRange*  
Application_TagTest::I4Tag::ValueRanges(int &sizeVRList) const
{
		static const ValueRange i4Tag_ValueRangeList[] = 
			{{ 0, 59, 1 }};

		sizeVRList = 1;
		return &i4Tag_ValueRangeList[0];
}

Application_TagTest::I5Tag & 
Application_TagTest::I5Tag::operator =(const I5Tag &that)
{
	m_len = that.m_len;
	delete[] m_bytes;
	m_bytes = new unsigned char[m_len];
	memcpy(m_bytes, that.m_bytes, m_len);
	return *this;
}

const ValueRange*  
Application_TagTest::I5Tag::ValueRanges(int &sizeVRList) const
{
		static const ValueRange i5Tag_ValueRangeList[] = 
			{{ 0, 59, 1 }};

		sizeVRList = 1;
		return &i5Tag_ValueRangeList[0];
}

void Application_TagTest::Init(void)
{
  i5Tag = new I5Tag(0);
}


int Application_TagTest::checkConstraints(ConstraintFailList* pConstraintFails) const{
	i1Tag.checkConstraints(pConstraintFails);

	i2Tag.checkConstraints(pConstraintFails);

	i4Tag.checkConstraints(pConstraintFails);

	if (i5Tag != NULL)
		i5Tag->checkConstraints(pConstraintFails);

	return 0;
}


void Application_TagTest::Clear()
{
  if(i5Tag)
    delete i5Tag;
  i5Tag = NULL;
}

Application_TagTest::Application_TagTest(const Application_TagTest &that)
{
   Init();
   *this = that;
}
AsnType *Application_TagTest::Clone() const
{
  return new Application_TagTest(*this);
}

Application_TagTest &Application_TagTest::operator = (const Application_TagTest &that)
{
  if (this != &that)
  {
    Clear();
    i1Tag = that.i1Tag;
    i2Tag = that.i2Tag;
    i4Tag = that.i4Tag;
    if (that.i5Tag)
    {
      if (!i5Tag)
        i5Tag = new I5Tag;
      *i5Tag = *that.i5Tag;
    }
    else
    {
      delete i5Tag;
      i5Tag = NULL;
    }
  }

  return *this;
}

AsnLen
Application_TagTest::BEncContent (AsnBuf &_b) const
{
  AsnLen totalLen = 0;
  AsnLen l=0;

  if ( NOT_NULL(i5Tag) && *i5Tag != 0 )
  {
    l = i5Tag->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, INTEGER_TAG_CODE);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
    totalLen += l;
  }

    l = i4Tag.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, INTEGER_TAG_CODE);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, UNIV, CONS, 21);
    totalLen += l;

    l = i2Tag.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, INTEGER_TAG_CODE);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 20);
    totalLen += l;

    l = i1Tag.BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, INTEGER_TAG_CODE);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
    totalLen += l;

  return totalLen;
} // Application_TagTest::BEncContent


void Application_TagTest::BDecContent (const AsnBuf &_b, AsnTag /*tag0*/, AsnLen elmtLen0, AsnLen &bytesDecoded)
{
  FUNC(" Application_TagTest::BDecContent");
  Clear();
  AsnTag tag1 = AsnTag();
  AsnLen seqBytesDecoded = 0;
  AsnLen elmtLen1 = 0;
  AsnLen elmtLen2 = 0;
  tag1 = BDecTag (_b, seqBytesDecoded);

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 0)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);

    if (tag1 != MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))
    {
          throw InvalidTagException(typeName(), tag1, STACK_ENTRY);
    }

    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    i1Tag.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (i1Tag)", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 20)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);

    if (tag1 != MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))
    {
          throw InvalidTagException(typeName(), tag1, STACK_ENTRY);
    }

    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    i2Tag.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    tag1 = BDecTag (_b, seqBytesDecoded);
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (i2Tag)", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (UNIV, CONS, 21)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);

    if (tag1 != MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))
    {
          throw InvalidTagException(typeName(), tag1, STACK_ENTRY);
    }

    elmtLen2 = BDecLen (_b, seqBytesDecoded);
    i4Tag.BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

    if (seqBytesDecoded == elmtLen0)
    {
      bytesDecoded += seqBytesDecoded;
      return;
    }
    else
    {
      tag1 = BDecTag (_b, seqBytesDecoded);

      if ((elmtLen0 == INDEFINITE_LEN) && (tag1 == EOC_TAG_ID))
      {
        BDEC_2ND_EOC_OCTET (_b, seqBytesDecoded);
        bytesDecoded += seqBytesDecoded;
        return;
      }
    }
  }
  else
  {
      throw EXCEPT("SEQUENCE is missing non-optional root elmt (i4Tag)", DECODE_ERROR);
  }

  if ((tag1 == MAKE_TAG_ID (CNTX, CONS, 2)))
  {
    elmtLen1 = BDecLen (_b, seqBytesDecoded);
    tag1 = BDecTag (_b, seqBytesDecoded);

    if (tag1 != MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))
    {
          throw InvalidTagException(typeName(), tag1, STACK_ENTRY);
    }

    elmtLen2 = BDecLen (_b, seqBytesDecoded);
  // delete default value
  delete i5Tag;
  i5Tag = new I5Tag;
    i5Tag->BDecContent (_b, tag1, elmtLen2, seqBytesDecoded);
    if (elmtLen1 == INDEFINITE_LEN)
      BDecEoc (_b, seqBytesDecoded);

  }

  bytesDecoded += seqBytesDecoded;
  if (elmtLen0 == INDEFINITE_LEN)
  {
    BDecEoc (_b, bytesDecoded);
    return;
  }
  else if (seqBytesDecoded != elmtLen0)
  {
    throw EXCEPT("Length discrepancy on sequence", DECODE_ERROR);
  }
  else
    return;
} // Application_TagTest::BDecContent

AsnLen Application_TagTest::BEnc (AsnBuf &_b) const
{
  AsnLen l=0;
  l = BEncContent (_b);
  l += BEncConsLen (_b, l);
  l += BEncTag1 (_b, UNIV, CONS, SEQ_TAG_CODE);
  return l;
}

void Application_TagTest::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
  FUNC(" Application_TagTest::BDec");
  AsnTag tag;
  AsnLen elmtLen1;

  if ((tag = BDecTag (_b, bytesDecoded)) != MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))
  {
    throw InvalidTagException(typeName(), tag, STACK_ENTRY);
  }
  elmtLen1 = BDecLen (_b, bytesDecoded);
  BDecContent (_b, tag, elmtLen1, bytesDecoded);
}

void Application_TagTest::Print(std::ostream& os, unsigned short indent) const
{
	os << "{ -- SEQUENCE --" << std::endl;
++indent;

	Indent(os, indent);
	os << "i1Tag ";
	i1Tag.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "i2Tag ";
	i2Tag.Print(os, indent);
	os << ',' << std::endl;

	Indent(os, indent);
	os << "i4Tag ";
	i4Tag.Print(os, indent);
	os << ',' << std::endl;

	if (NOT_NULL (i5Tag))
	{
		os << ","<< std::endl;
		Indent(os, indent);
		os << "i5Tag ";
		i5Tag->Print(os, indent);
	}

	os << std::endl;
	--indent;
	Indent(os, indent);
	os << "}\n";
} // end of Application_TagTest::Print()

void Application_TagTest::PrintXML (std::ostream &os, const char *lpszTitle) const
{
    const char *tagName = typeName();
    if (lpszTitle)
        tagName = lpszTitle;
    os << "<" << tagName << ">";
    i1Tag.PrintXML(os, "i1Tag");

    i2Tag.PrintXML(os, "i2Tag");

    i4Tag.PrintXML(os, "i4Tag");

    if (NOT_NULL (i5Tag)) {
        i5Tag->PrintXML(os, "i5Tag");
    }

    os << "</" << tagName << ">";
} // Application_TagTest::PrintXML


Application_TagChoice::I1Choice & 
Application_TagChoice::I1Choice::operator =(const I1Choice &that)
{
	m_len = that.m_len;
	delete[] m_bytes;
	m_bytes = new unsigned char[m_len];
	memcpy(m_bytes, that.m_bytes, m_len);
	return *this;
}

const ValueRange*  
Application_TagChoice::I1Choice::ValueRanges(int &sizeVRList) const
{
		static const ValueRange i1Choice_ValueRangeList[] = 
			{{ 0, 23, 1 }};

		sizeVRList = 1;
		return &i1Choice_ValueRangeList[0];
}

Application_TagChoice::I2Choice & 
Application_TagChoice::I2Choice::operator =(const I2Choice &that)
{
	m_len = that.m_len;
	delete[] m_bytes;
	m_bytes = new unsigned char[m_len];
	memcpy(m_bytes, that.m_bytes, m_len);
	return *this;
}

const ValueRange*  
Application_TagChoice::I2Choice::ValueRanges(int &sizeVRList) const
{
		static const ValueRange i2Choice_ValueRangeList[] = 
			{{ 0, 59, 1 }};

		sizeVRList = 1;
		return &i2Choice_ValueRangeList[0];
}

Application_TagChoice::I3Choice & 
Application_TagChoice::I3Choice::operator =(const I3Choice &that)
{
	m_len = that.m_len;
	delete[] m_bytes;
	m_bytes = new unsigned char[m_len];
	memcpy(m_bytes, that.m_bytes, m_len);
	return *this;
}

const ValueRange*  
Application_TagChoice::I3Choice::ValueRanges(int &sizeVRList) const
{
		static const ValueRange i3Choice_ValueRangeList[] = 
			{{ 0, 59, 1 }};

		sizeVRList = 1;
		return &i3Choice_ValueRangeList[0];
}

Application_TagChoice::Application_TagChoice(const Application_TagChoice &that)
{
   Init();
   *this = that;
}
void Application_TagChoice::Init(void)
{
   // initialize choice to no choiceId to first choice and set pointer to NULL
  choiceId = i1ChoiceCid;
  i1Choice = NULL;
}


int Application_TagChoice::checkConstraints(ConstraintFailList* pConstraintFails) const
{
	if (i1Choice != NULL)
		i1Choice->checkConstraints(pConstraintFails);

	if (i2Choice != NULL)
		i2Choice->checkConstraints(pConstraintFails);

	if (i3Choice != NULL)
		i3Choice->checkConstraints(pConstraintFails);

	if (i4Choice != NULL)
		i4Choice->checkConstraints(pConstraintFails);

	return 0;
}


void Application_TagChoice::Clear()
{
  switch (choiceId)
  {
    case i1ChoiceCid:
      delete i1Choice;
      i1Choice = NULL;
      break;
    case i2ChoiceCid:
      delete i2Choice;
      i2Choice = NULL;
      break;
    case i3ChoiceCid:
      delete i3Choice;
      i3Choice = NULL;
      break;
    case i4ChoiceCid:
      delete i4Choice;
      i4Choice = NULL;
      break;
  } // end of switch
} // end of Clear()

AsnType *Application_TagChoice::Clone() const
{
  return new Application_TagChoice(*this);
}

Application_TagChoice &Application_TagChoice::operator = (const Application_TagChoice &that)
{
    if (this != &that) {
        Clear();
        if (that.i1Choice != NULL) {
            switch (choiceId = that.choiceId) {
                case i1ChoiceCid:
                    i1Choice = new I1Choice(*that.i1Choice);
                break;
                case i2ChoiceCid:
                    i2Choice = new I2Choice(*that.i2Choice);
                break;
                case i3ChoiceCid:
                    i3Choice = new I3Choice(*that.i3Choice);
                break;
                case i4ChoiceCid:
                    i4Choice = new AsnInt(*that.i4Choice);
                break;
            }
        }
    }

    return *this;
}

AsnLen
Application_TagChoice::BEncContent (AsnBuf &_b) const
{
    FUNC("Application_TagChoice::BEncContent (AsnBuf &_b)");
  AsnLen l=0;
  switch (choiceId)
  {
    case i1ChoiceCid:
      l = i1Choice->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, INTEGER_TAG_CODE);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 0);
      break;

    case i2ChoiceCid:
      l = i2Choice->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, INTEGER_TAG_CODE);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 20);
      break;

    case i3ChoiceCid:
      l = i3Choice->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, INTEGER_TAG_CODE);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, UNIV, CONS, 21);
      break;

    case i4ChoiceCid:
      l = i4Choice->BEncContent (_b);
    l += BEncDefLen (_b, l);

    l += BEncTag1 (_b, UNIV, PRIM, INTEGER_TAG_CODE);
    l += BEncConsLen (_b, l);

    l += BEncTag1 (_b, CNTX, CONS, 2);
      break;

      default:
         throw EXCEPT("Choice is empty", ENCODE_ERROR);
  } // end switch
  return l;
} // Application_TagChoice::BEncContent


void Application_TagChoice::BDecContent (const AsnBuf &_b, AsnTag tag, AsnLen elmtLen0, AsnLen &bytesDecoded /*, s env*/)
{
   FUNC("Application_TagChoice::BDecContent()");
   Clear();
  AsnLen elmtLen1 = 0;
  switch (tag)
  {
    case MAKE_TAG_ID (CNTX, CONS, 0):
      tag = BDecTag (_b, bytesDecoded);
      if (tag != MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))
      {
        throw InvalidTagException(typeName(), tag, STACK_ENTRY);
      }

      elmtLen1 = BDecLen (_b, bytesDecoded);
      choiceId = i1ChoiceCid;
        i1Choice = new I1Choice;
        i1Choice->BDecContent (_b, tag, elmtLen1, bytesDecoded);
      if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (_b, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 20):
      tag = BDecTag (_b, bytesDecoded);
      if (tag != MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))
      {
        throw InvalidTagException(typeName(), tag, STACK_ENTRY);
      }

      elmtLen1 = BDecLen (_b, bytesDecoded);
      choiceId = i2ChoiceCid;
        i2Choice = new I2Choice;
        i2Choice->BDecContent (_b, tag, elmtLen1, bytesDecoded);
      if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (_b, bytesDecoded);
      break;

    case MAKE_TAG_ID (UNIV, CONS, 21):
      tag = BDecTag (_b, bytesDecoded);
      if (tag != MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))
      {
        throw InvalidTagException(typeName(), tag, STACK_ENTRY);
      }

      elmtLen1 = BDecLen (_b, bytesDecoded);
      choiceId = i3ChoiceCid;
        i3Choice = new I3Choice;
        i3Choice->BDecContent (_b, tag, elmtLen1, bytesDecoded);
      if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (_b, bytesDecoded);
      break;

    case MAKE_TAG_ID (CNTX, CONS, 2):
      tag = BDecTag (_b, bytesDecoded);
      if (tag != MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))
      {
        throw InvalidTagException(typeName(), tag, STACK_ENTRY);
      }

      elmtLen1 = BDecLen (_b, bytesDecoded);
      choiceId = i4ChoiceCid;
        i4Choice = new AsnInt;
        i4Choice->BDecContent (_b, tag, elmtLen1, bytesDecoded);
      if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (_b, bytesDecoded);
      break;

    default:
    {        throw InvalidTagException(typeName(), tag, STACK_ENTRY);
      break;
    }
  } // end switch
} // Application_TagChoice::BDecContent


AsnLen Application_TagChoice::BEnc (AsnBuf &_b) const
{
    AsnLen l=0;
    l = BEncContent (_b);
    return l;
}

void Application_TagChoice::BDec (const AsnBuf &_b, AsnLen &bytesDecoded)
{
    AsnLen elmtLen = 0;
    AsnTag tag;

    /*  CHOICEs are a special case - grab identifying tag */
    /*  this allows easier handling of nested CHOICEs */
    tag = BDecTag (_b, bytesDecoded);
    elmtLen = BDecLen (_b, bytesDecoded);
    BDecContent (_b, tag, elmtLen, bytesDecoded);
}

void Application_TagChoice::Print(std::ostream& os, unsigned short indent) const
{
	switch (choiceId)
	{
	case i1ChoiceCid:
		os << "i1Choice ";
		if (i1Choice)
			i1Choice->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case i2ChoiceCid:
		os << "i2Choice ";
		if (i2Choice)
			i2Choice->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case i3ChoiceCid:
		os << "i3Choice ";
		if (i3Choice)
			i3Choice->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	case i4ChoiceCid:
		os << "i4Choice ";
		if (i4Choice)
			i4Choice->Print(os, indent);
		else
			os << "<CHOICE value is missing>\n";
		break;

	} // end of switch
} // end of Application_TagChoice::Print()

void Application_TagChoice::PrintXML (std::ostream &os, const char *lpszTitle) const
{
    const char *tagName = typeName();
    if (lpszTitle)
        tagName = lpszTitle;    os << "<" << tagName << ">";
    switch (choiceId) {
    case i1ChoiceCid:
       if (i1Choice) {
           i1Choice->PrintXML(os,"i1Choice");
      }
      break;

    case i2ChoiceCid:
       if (i2Choice) {
           i2Choice->PrintXML(os,"i2Choice");
      }
      break;

    case i3ChoiceCid:
       if (i3Choice) {
           i3Choice->PrintXML(os,"i3Choice");
      }
      break;

    case i4ChoiceCid:
       if (i4Choice) {
           i4Choice->PrintXML(os,"i4Choice");
      }
      break;

    } // end of switch
    os << "</" << tagName << ">";
} // Application_TagChoice::PrintXML

#ifndef NO_NAMESPACE
} // namespace close
#endif
